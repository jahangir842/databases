# ⭐ **50 Scenario-Based MongoDB Questions (with Answers)**

*(Grouped by topic for easier memorization)*

---

# **A. Deployment & Infrastructure (1–10)**

---

### **1. Scenario:** You deployed MongoDB but it keeps restarting.

**Cause?**

* Wrong filesystem permissions
* PID file issues
* Port already in use
* Incorrect YAML indentation
* Not enough RAM

**Fix:**
Check logs:

```bash
journalctl -u mongod -f
```

---

### **2. Scenario:** MongoDB won’t bind to 0.0.0.0

**Fix:**
Modify `/etc/mongod.conf`

```yaml
net:
  bindIp: 0.0.0.0
```

Restart service.

---

### **3. Scenario:** MongoDB starts but replica set init fails

**Reason:**

* Hostname mismatch
* Different bind IP values
* Clock/time mismatch

**Fix:**
Ensure:

```bash
timedatectl set-ntp true
```

---

### **4. Scenario:** MongoDB on Docker losing data after restart

**Fix:**
Mount volume:

```yaml
volumes:
  - ./mongo_data:/data/db
```

---

### **5. Scenario:** MongoDB container crashing due to wrong UID

**Fix:**
Use correct ownership

```bash
chown -R 999:999 mongo_data/
```

---

### **6. Scenario:** MongoDB CPU spikes to 100%

**Reason:**

* Full collection scan
* Missing index
* Too many connections

**Fix:**
Check slow ops:

```javascript
db.currentOp()
```

---

### **7. Scenario:** MongoDB takes long to restart after crash

**Reason:**
WiredTiger journal recovery.

**Fix:**
Move journal to faster SSD.

---

### **8. Scenario:** MongoDB dump is slow

**Fix:**
Use parallelism:

```bash
mongodump --numParallelCollections=8
```

---

### **9. Scenario:** Need to migrate MongoDB from on-prem → AWS

**Solution Paths:**

* mongodump + mongorestore
* Atlas live migration tool
* Cloud-backed snapshots

---

### **10. Scenario:** You must upgrade MongoDB with zero downtime

**Approach:**

* Use **rolling upgrade** on replica set
* Upgrade secondaries → stepDown → upgrade primary

---

# **B. Replica Sets (11–20)**

---

### **11. Scenario:** Secondary is stuck in RECOVERING

**Cause:**
Delayed replication or insufficient oplog.

**Fix:**
Increase oplog size.

---

### **12. Scenario:** Two primaries appear in logs

**Cause:**
Split-brain due to network partition.

**Fix:**
Set proper priorities + add arbiter if odd nodes.

---

### **13. Scenario:** `rs.status()` shows “not syncing”

**Fix:**
Check source:

```javascript
rs.syncFrom("node2:27017")
```

---

### **14. Scenario:** Secondary extremely slow

**Possible Reasons:**

* HDD instead of SSD
* Cache pressure
* Slow network
* Large writes

**Fix:**
Move secondary to SSD or reduce load.

---

### **15. Scenario:** Need analytics without affecting production

**Solution:**
Add **hidden secondary**:

```javascript
priority: 0,
hidden: true
```

---

### **16. Scenario:** Secondary delay configured incorrectly

**Fix:**
Use:

```javascript
rs.reconfig({...}, {force: true})
```

---

### **17. Scenario:** You need copies of data in another region

**Fix:**
Add replica set members in remote region with proper priority.

---

### **18. Scenario:** Primary keeps stepping down

**Cause:**

* High heartbeat latency
* CPU overload

**Fix:**
Check logs + increase electionTimeoutMillis.

---

### **19. Scenario:** Failover takes > 10 seconds

**Fix:**
Tune parameter:

```yaml
settings:
  electionTimeoutMillis: 2000
```

---

### **20. Scenario:** You want to test failover manually

**Solution:**

```javascript
rs.stepDown()
```

---

# **C. Sharding (21–30)**

---

### **21. Scenario:** Some queries always go to same shard

**Fix:**
Use **hashed shard key**.

---

### **22. Scenario:** Sharded cluster shows “jumbo chunks”

**Cause:**
Chunk too large to migrate.

**Fix:**

* Increase split threshold
* Clean large documents
* Reselect shard key

---

### **23. Scenario:** mongos using high memory

**Reason:**
Many long-running aggregations.

**Fix:**
Use pipeline stages with `$project` early.

---

### **24. Scenario:** Data migration between shards is slow

**Fix:**
Increase balancer threads:

```javascript
sh.setBalancerState(true)
```

---

### **25. Scenario:** Config servers down → whole cluster fails

**Fix:**
Always use **3 config servers**, never 1.

---

### **26. Scenario:** You want to add new shard to existing cluster

**Command:**

```javascript
sh.addShard("rs2/mongo2:27017")
```

---

### **27. Scenario:** Database is not sharded at all

**Reason:**
Must enable explicitly:

```javascript
sh.enableSharding("dbName")
```

---

### **28. Scenario:** Chunk migrations degrading performance

**Fix:**
Run migration only during off-peak

```javascript
sh.setBalancerState(false)
```

---

### **29. Scenario:** Need geo-distribution of data

**Fix:**
Use **zone sharding**.

---

### **30. Scenario:** Query scatter-gather affecting latency

**Fix:**
Ensure query includes *shard key* so it hits only one shard.

---

# **D. Indexing & Performance (31–40)**

---

### **31. Scenario:** Index too large for RAM

**Fix:**

* Use partial indexes
* Use smaller data types

---

### **32. Scenario:** Query not using compound index

**Fix:**
Match prefix order:
For index `{a:1, b:1}`, query must include `a`.

---

### **33. Scenario:** Wildcard queries causing collection scans

**Fix:**
Avoid `/.*pattern/` — use anchored regex.

---

### **34. Scenario:** Unique index creation fails

**Cause:**
Duplicate data already exists.

**Fix:**
Identify duplicates:

```javascript
db.col.aggregate([
  { $group: { _id: "$email", count: { $sum: 1 }}},
  { $match: { count: { $gt: 1 }}}
])
```

---

### **35. Scenario:** Need TTL for automatic cleanup

**Fix:**

```javascript
db.logs.createIndex({ "createdAt": 1 }, { expireAfterSeconds: 3600 })
```

---

### **36. Scenario:** Slow sort operations

**Fix:**
Create index supporting sort order.

---

### **37. Scenario:** Query too slow after upgrade

**Possibility:**
Query planner changed.
Use `hint()`.

---

### **38. Scenario:** Need text search

**Fix:**
Create text index:

```javascript
db.products.createIndex({name: "text"})
```

---

### **39. Scenario:** Need case-insensitive search

**Fix:**
Avoid regex; store normalized data.

---

### **40. Scenario:** Aggregation using too much RAM

**Fix:**
Enable disk usage:

```javascript
db.col.aggregate([...], { allowDiskUse: true })
```

---

# **E. Security (41–45)**

---

### **41. Scenario:** MongoDB exposed on internet

**Fix:**

* Bind to internal network
* Enable auth
* Enable firewall
* Use TLS

---

### **42. Scenario:** Need to encrypt data at rest

**Fix:**
Use WiredTiger Encrypted Storage Engine or disk-level encryption (LUKS/EBS).

---

### **43. Scenario:** Password rotation required

**Fix:**
Create multiple users → rotate → revoke old credentials.

---

### **44. Scenario:** Need audit logging

**Fix:**
Enable audit filter in config:

```yaml
auditLog:
  destination: file
```

---

### **45. Scenario:** Protect from brute force

**Fix:**
Rate-limit connecting services using firewall rules.

---

# **F. Transactions & Consistency (46–50)**

---

### **46. Scenario:** Multi-document update must be atomic

**Fix:**
Use session-based transaction.

---

### **47. Scenario:** Transactions too slow

**Reason:**

* Large documents
* Large isolation window
* High read/write concern
* Poor shard key

**Fix:**
Reduce scope and size.

---

### **48. Scenario:** Need to ensure write durability

**Fix:**
Use `writeConcern: { j: true }`

---

### **49. Scenario:** Reading stale data from secondary

**Fix:**
Use read concern:

```javascript
readConcern: { level: "majority" }
```

---

### **50. Scenario:** Transaction aborted due to `WriteConflict`

**Fix:**
Retry transaction:

```javascript
session.withTransaction(() => { ... })
```

---
